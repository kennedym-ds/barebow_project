# Review: FastAPI API Layer — Bug & Edge-Case Audit

**Date**: 2026-02-11T00:00:00Z  
**Reviewer**: reviewer-agent  
**Verdict**: NEEDS_REVISION

## Summary

Thorough review of all 10 router files, `api/main.py`, `api/deps.py`, plus the domain modules they call. Found 14 actionable issues spanning data-loss, crash, wrong-result, and security categories.

---

## Findings

| # | Severity | File | Line | Issue | Trigger | Recommendation |
|---|----------|------|------|-------|---------|----------------|
| 1 | **data-loss** | `api/routers/bows.py` | 105–110 | **Deleting a BowSetup that has Sessions creates orphan sessions.** `BowSetup.sessions` relationship has no `cascade` configured (only plain `Relationship(back_populates="bow")`). SQLite FK enforcement is off by default, so `db.delete(bow)` succeeds, leaving `Session.bow_id` pointing at a nonexistent row. Subsequent reads return `session.bow = None`, silently hiding the deleted equipment. | `DELETE /api/bows/{id}` when sessions reference that bow. | Either add `sa_relationship_kwargs={"cascade": "all, delete"}` to `BowSetup.sessions` (destructive — also deletes the sessions), or check for referencing sessions and return `409 Conflict`, or set `bow_id = NULL` on referencing sessions before deleting. |
| 2 | **data-loss** | `api/routers/arrows.py` | 93–100 | **Same orphan problem for ArrowSetup → Sessions.** `ArrowSetup.sessions` has no cascade. Deleting an arrow setup orphans every session that references it. | `DELETE /api/arrows/{id}` when sessions reference that arrow. | Same options as #1. |
| 3 | **crash** | `api/routers/crawls.py` | 51–52 | **`calculate_crawl_regression` crashes with empty lists.** If `known_distances` is empty, `np.polyfit([], [], 0)` raises `np.linalg.LinAlgError`. The `CrawlCalculateRequest` schema only validates types, not min-length. | `POST /api/crawls/calculate` with `{"known_distances": [], "known_crawls": []}`. | Add `min_length=1` (or `min_length=2`) constraint to the Pydantic fields, or add a guard in the handler returning 422. |
| 4 | **crash** | `api/routers/crawls.py` | 73–74 | **Same crash in `/predict`.** `CrawlPredictRequest` also allows empty lists. | `POST /api/crawls/predict` with empty lists. | Same fix: validate min length. |
| 5 | **crash** | `api/routers/crawls.py` | 44–50 | **`known_distances` and `known_crawls` length mismatch.** If the two lists have different lengths, `np.polyfit` raises `TypeError: expected x and y to have the same length`. No validation enforces equal length. | `POST /api/crawls/calculate` with `{"known_distances": [10, 20], "known_crawls": [5]}`. | Add a `model_validator` or explicit check before calling domain logic. |
| 6 | **wrong-result** | `api/routers/scoring.py` | 32–35 | **`get_ring_score` gives score 10 when `radius_cm == 0` (hit dead center) but `math.ceil(0 / ring_width) == 0`, so `ring_index <= 1` is True — correct for score. However, `is_x` logic on line 35 uses `radius_cm <= x_radius` where `x_radius = ring_width / 2`. For `face_cm = 40`, `ring_width = 2`, `x_radius = 1`. A shot at radius 0.9 cm is scored as X. But `get_ring_score` inside `scoring.py` only checks the X ring for `x_is_11=True` (compound). The API endpoint's `is_x` logic diverges from the domain function.** The result is that the API's `is_x` calculation is reimplemented inline, bypassing the domain layer, and would disagree if the domain definition ever changes. More critically: for the Flint face type, `is_x` is hardcoded to `False`, which is correct, but the radius calculation for the X ring on WA faces uses `face_cm / 20 / 2` — this is `face_cm / 40`. For a 122 cm face, X radius would be 3.05 cm — that is wrong; the WA X-ring is actually the inner half of the 10-ring, which has radius `face_cm / 20 = 6.1 cm`, so the X-ring outer radius is `6.1 / 2 = 3.05 cm`. OK, this is actually right. **However**, the `is_x` check doesn't account for `x_is_11` at all — a shot at radius 0 with `x_is_11=False` gets `is_x=True` AND `score=10`. With `x_is_11=True`, the domain returns `score=11`, but the API still returns `is_x=True` and `score=11`. This is fine. Downgrading — the real issue is **the X-ring logic is duplicated** outside the domain layer. If someone later changes the X-ring definition in `scoring.py`, the API will return inconsistent results. | Any `/api/scoring/ring` call. | Move the `is_x` determination into `src/scoring.py` so the API just returns what the domain says. |
| 7 | **crash** | `api/routers/analytics.py` | 589 | **`calculate_sigma_from_score` called with avg_score > 10.** When `shot_count > 0`, `avg_score` is calculated from the data. However, if `x_is_11` compound scoring is ever stored (score 11 for X-ring), `avg_score` can exceed 10. `calculate_sigma_from_score` with `score >= 10` returns `0.0`, so it won't crash — but it returns a **wrong sigma of 0.0** making the session appear to have perfect precision. | Sessions with compound-scored X-ring values (score=11) would get sigma_cm = 0.0. | Clamp `avg_score` to `[0, 10]` before calling `calculate_sigma_from_score`, or handle it in the domain function. |
| 8 | **crash** | `api/routers/analytics.py` | 568–569 | **`get_average_score_for_round` returns `(None, 0, 0, 0)` when no sessions found.** Line 589 checks `if short_avg is None or long_avg is None`, but the zero values for `short_count` etc. are used in the fallback `ParkModelAnalysis`. The `short_dist` and `short_face` come back as `0`, so `sigma_theta_rad = short_sigma / (short_dist * 100.0)` would be a **division by zero** — except it's guarded by the `None` check. This is actually safe. Withdrawn. | N/A | N/A |
| 9 | **security** | `api/routers/tabs.py` | 128 | **File extension extracted from user-supplied filename without sanitization.** `ext = file.filename.rsplit(".", 1)[-1]` takes whatever extension the user uploaded. A filename like `evil.php` would create a file `{tab_id}_{hex}.php` in the uploads directory. While `FileResponse` just serves bytes and the content-type validation on line 120 limits accepted MIME types, the stored filename could be misleading, and MIME type checks rely on the client-declared `content_type`, which can be spoofed. | `POST /api/tabs/{id}/image` with `Content-Type: image/jpeg` but filename `evil.php`. | Whitelist allowed extensions (`jpg`, `png`, `webp`) rather than trusting the uploaded filename. Also validate the file's magic bytes, not just the declared content type. |
| 10 | **crash** | `api/routers/analytics.py` | 337–341 | **`datetime.fromisoformat` will crash on malformed date strings.** Every analytics endpoint uses `datetime.fromisoformat(from_date)` / `datetime.fromisoformat(to_date)` with no try/except. Invalid dates like `"not-a-date"` will raise `ValueError`, producing a raw 500 error instead of a 422 validation error. | `GET /api/analytics/summary?from_date=hello`. | Either use a `datetime` or `date` type in the Query parameter (FastAPI validates automatically), or wrap in try/except returning 422. |
| 11 | **edge-case** | `api/routers/sessions.py` | 152–155 | **Creating a session returns raw `SessionModel` including relationship fields.** The response_model is `SessionModel` (the SQLModel table class). SQLModel table classes may include lazy-loaded relationship attributes (`bow`, `arrow`, `ends`). After `db.refresh(session)`, these relationships are unloaded. FastAPI's serialization may raise `MissingGreenlet` / lazy-loading errors if the ORM tries to follow the relationships outside the session scope, depending on SQLAlchemy version. This is inconsistent with the detail endpoint which uses `SessionDetailResponse`. | `POST /api/sessions` — the response serialization may fail or return incomplete data. | Use a dedicated `SessionCreateResponse` Pydantic schema without relationship fields, or return `SessionDetailResponse`. |
| 12 | **wrong-result** | `api/routers/analytics.py` | 1459–1467 | **`rolling_avg` EWMA is computed in chronological order but the iteration starts with the first session's avg score and walks forward.** The EWMA weighting gives the most recent sessions the most influence. But `session_stats` is sorted by `date DESC` (line 1427), so `reversed_stats` is chronological. The EWMA starts at the oldest session and walks to the newest. The final `ewma` value is correct (most-recent-weighted). However, the interpretation is "rolling average" and the alpha is `2/(10+1)=0.18`. With very few sessions, the EWMA is dominated by the first session (oldest), not the most recent. This is a minor wrong-result for few sessions but technically correct for many. | Dashboard with < 5 sessions. | Consider using the last session as the initial EWMA value, or use a simple trailing average for few sessions. |
| 13 | **edge-case** | `api/routers/analytics.py` | 1332–1340 | **Equipment comparison endpoint allows all query params to be `None`.** If both `setup_a_*` and `setup_b_*` are all `None`, `get_setup_stats` runs with no equipment filter, returning the same data for both A and B. The comparison then says "no significant difference" between identical data. Not a crash, but returns misleading results. | `GET /api/analytics/equipment-comparison` with no query params. | Require at least one identifier per setup, or return 422 if both setups resolve to identical filters. |
| 14 | **wrong-result** | `api/routers/analytics.py` | 786–791 | **`first_arrow_scores` is determined by `idx == 0` (the shot's index in `end.shots` list), but SQLAlchemy returns shots in arbitrary order** unless explicitly sorted. The "first arrow" may not actually be the first shot fired. | `GET /api/analytics/bias-analysis` — first-arrow analysis could use a random shot as "first". | Add `.order_by(Shot.id)` or similar deterministic ordering to the relationship or query, or use `shot.arrow_number == 1` as the first-arrow indicator. |

## Test Evidence

Last test run (from terminal) exited with code 0 — all existing tests pass. However, the existing tests do not cover:
- Deleting a bow/arrow that has sessions referencing it
- Empty-list or mismatched-list crawl requests
- Malformed date strings on analytics endpoints
- File uploads with spoofed content types

## Follow-up Items

- [ ] **[BLOCKER]** Fix #1 and #2 — orphaned sessions on bow/arrow delete. Decide on cascade-delete vs. 409 vs. null-out strategy.
- [ ] **[BLOCKER]** Fix #3, #4, #5 — add input validation to crawl endpoints (min length, equal length).
- [ ] **[HIGH]** Fix #9 — sanitize file extension on tab image upload.
- [ ] **[HIGH]** Fix #10 — use proper `datetime` type for date query params across all analytics endpoints.
- [ ] **[HIGH]** Fix #14 — ensure deterministic shot ordering for first-arrow analysis.
- [ ] **[MEDIUM]** Fix #11 — use a proper response schema for `POST /api/sessions`.
- [ ] **[MEDIUM]** Fix #7 — clamp avg_score before calling `calculate_sigma_from_score`.
- [ ] **[LOW]** Fix #6 — consolidate X-ring logic into domain layer.
- [ ] **[LOW]** Fix #12, #13 — EWMA edge case and equipment-comparison parameter validation.
